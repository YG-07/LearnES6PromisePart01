<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

<script>
  //本节使用setTimeout定时器模拟网络请求！
  // setTimeout(() => {
  //   console.log('Hello World!');
  // }, 1000)
  /*
    参数 -> 函数(resolve, reject)
    (resolve, reject)也是函数,链式编程
    new Promise((resolve, reject)=>{...}). then(()=>{...}). then(()=>{...}). then(()=>{...})
  */

  //一、链式调用
  new Promise((resolve, reject) => {
    //1.第1次请求
    setTimeout(() => {
      resolve()
    }, 1000)
  }).then(() => {
    //2.第1次处理的代码
    console.log('第一次请求');
    console.log('第一次请求');
    console.log('第一次请求');

  return new Promise((resolve, reject) => {
      //1.第2次请求
      setTimeout(() => {
        resolve()
      }, 1000)
    })
  }).then(() => {
    // 2.第2次处理的代码
    console.log('第二次请求');
    console.log('第二次请求');
    console.log('第二次请求');
    console.log('第二次请求');

  return new Promise((resolve, reject) => {
      //1.第3次请求
      setTimeout(() => {
        resolve()
      }, 1000)
    })
  }).then(() => {
    // 2.第3次处理的代码
    console.log('第三次请求');
    console.log('第三次请求');
    console.log('第三次请求');
    console.log('第三次请求');
    console.log('第三次请求');
    console.log('第三次请求');
  })

  // 处理resolve传递参数，then里面处理
  new Promise((resolve, reject) => {
    setTimeout(() => {
      // resolve('Hello')
      reject('Error Message')
    }, 1000)
  }).then((data) => {
    console.log(data);
    console.log(data);
    console.log(data);
  }).catch((err) => {
    console.log(err);
    console.log(err);
    console.log(err);
    console.log(err);
  })
  /*
    什么情况下会用到Promise？
    一般情况下是有异步操炸时，使用Promise对这个异步操作进行封装
    executor:执行器
    new->构造函数（1.保存了一些状态信息2.执行传入的函数）
    在执行传入的回调函数时，会传入两个参数，resolve，reject.本身又是函数
  */

</script>
</body>
</html>